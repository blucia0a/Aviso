diff -rupN llvm-3.1.src/include/llvm/InitializePasses.h llvm-3.1.src.aviso/include/llvm/InitializePasses.h
--- llvm-3.1.src/include/llvm/InitializePasses.h	2012-02-13 14:50:51.000000000 -0800
+++ llvm-3.1.src.aviso/include/llvm/InitializePasses.h	2012-08-02 14:56:02.000000000 -0700
@@ -251,6 +251,7 @@ void initializeInstSimplifierPass(PassRe
 void initializeUnpackMachineBundlesPass(PassRegistry&);
 void initializeFinalizeMachineBundlesPass(PassRegistry&);
 void initializeBBVectorizePass(PassRegistry&);
+void initializeAvisoInstrumentPass(PassRegistry&);
 }
 
 #endif
diff -rupN llvm-3.1.src/include/llvm/Transforms/Instrumentation.h llvm-3.1.src.aviso/include/llvm/Transforms/Instrumentation.h
--- llvm-3.1.src/include/llvm/Transforms/Instrumentation.h	2012-02-13 14:50:51.000000000 -0800
+++ llvm-3.1.src.aviso/include/llvm/Transforms/Instrumentation.h	2012-08-02 14:58:00.000000000 -0700
@@ -38,6 +38,9 @@ ModulePass *createAddressSanitizerPass()
 // Insert ThreadSanitizer (race detection) instrumentation
 FunctionPass *createThreadSanitizerPass();
 
+//Insert AvisoInstrument (debug-based codepoint instrumentation)
+FunctionPass *createAvisoInstrumentPass();
+
 } // End llvm namespace
 
 #endif
diff -rupN llvm-3.1.src/lib/Transforms/Instrumentation/AvisoInstrument.cpp llvm-3.1.src.aviso/lib/Transforms/Instrumentation/AvisoInstrument.cpp
--- llvm-3.1.src/lib/Transforms/Instrumentation/AvisoInstrument.cpp	1969-12-31 16:00:00.000000000 -0800
+++ llvm-3.1.src.aviso/lib/Transforms/Instrumentation/AvisoInstrument.cpp	2012-08-02 15:00:34.000000000 -0700
@@ -0,0 +1,216 @@
+#include <iostream>
+#include <string>
+#include <fstream>
+#include <set>
+#include <ext/hash_map>
+using __gnu_cxx::hash_map;
+
+#include <utility>
+
+#define DEBUG_TYPE "aviso"
+#include <llvm/Pass.h>
+#include <llvm/Function.h>
+#include <llvm/Instruction.h>
+#include <llvm/Metadata.h>
+#include <llvm/LLVMContext.h>
+#include <llvm/Value.h>
+#include <llvm/Type.h>
+#include <llvm/Constants.h>
+#include <llvm/Instructions.h>
+#include <llvm/Module.h>
+#include <llvm/ADT/StringExtras.h>
+#include <llvm/ADT/Statistic.h>
+#include <llvm/Analysis/DebugInfo.h>
+#include <llvm/Analysis/Dominators.h>
+#include <llvm/Support/InstIterator.h>
+#include <llvm/Transforms/Instrumentation.h>
+
+using namespace llvm;
+
+extern "C"{
+  /*These needed to be added because with LLVM 3.1 they were undefined for some reason.
+    They are not important for this pass, so I think this is OK.*/
+  LLVM_ATTRIBUTE_WEAK void AnnotateHappensAfter(const char *file, int line,
+                                              const volatile void *cv){}
+  LLVM_ATTRIBUTE_WEAK void AnnotateHappensBefore(const char *file, int line,
+                                               const volatile void *cv){}
+  LLVM_ATTRIBUTE_WEAK void AnnotateIgnoreWritesBegin(const char *file, int line){}
+  LLVM_ATTRIBUTE_WEAK void AnnotateIgnoreWritesEnd(const char *file, int line){}
+}
+
+
+namespace {
+
+  class AvisoInstrument : public FunctionPass{
+
+  public:
+
+    static char ID;
+    DominatorTreeBase<BasicBlock>* DT;
+    std::set< std::pair<std::string, unsigned int> > points;
+    Constant *eventFunc;
+    AvisoInstrument();
+    ~AvisoInstrument();
+
+    bool dominates(const BasicBlock* A, const BasicBlock* B);
+    bool properlyDominates(BasicBlock *A, BasicBlock *B);
+    virtual bool doInitialization(Module &M);
+    virtual bool doFinalization(Module &M);
+    virtual bool runOnFunction(Function &F); 
+
+};
+
+}
+
+char AvisoInstrument::ID = 0;
+INITIALIZE_PASS(AvisoInstrument, "aviso", "Insert Aviso Instrumentation", false, false)
+
+AvisoInstrument::AvisoInstrument() : FunctionPass(ID), eventFunc(NULL) {
+
+    DT = new DominatorTreeBase<BasicBlock>(false);
+
+    char *pFile = getenv("AVISOPOINTS");
+
+    std::ifstream reader(pFile);
+
+    char filename[512];
+
+    unsigned int line;
+
+    while (reader.good()) {
+
+        reader >> filename;
+
+        reader >> line;
+
+        std::pair<std::string, unsigned int> point(filename, line);
+
+        points.insert(point);
+
+    }
+
+    std::cerr << "[AVISO] Instrumenting at " << points.size() << " points\n";
+
+}
+
+AvisoInstrument::~AvisoInstrument() {
+
+    if (points.size() == 0) {
+
+        std::cerr << "[AVISO] All points instrumented\n";
+
+    } else {
+
+        std::cerr << "[AVISO] These points not instrumented:\n";
+
+        for (std::set< std::pair<std::string, unsigned int> >::iterator
+             i = points.begin(); i != points.end(); ++i) {
+            std::cerr << "  " << i->first << ":" << i->second << "\n";
+        }
+
+    }
+
+    delete DT;
+}
+
+
+
+FunctionPass *llvm::createAvisoInstrumentPass(){
+  return new AvisoInstrument();
+}
+
+bool AvisoInstrument::doInitialization(Module &M) {
+  eventFunc = M.getOrInsertFunction("IR_SyntheticEvent", Type::getVoidTy(M.getContext()), NULL);
+  return false;
+}
+ 
+bool AvisoInstrument::doFinalization(Module &M) {
+  return true;
+}
+
+
+bool AvisoInstrument::dominates(const BasicBlock* A, const BasicBlock* B) {
+  return DT->dominates(A, B);
+}
+  
+bool AvisoInstrument::properlyDominates(BasicBlock *A, BasicBlock *B) {
+  return DT->properlyDominates(A, B);
+}
+
+bool AvisoInstrument::runOnFunction(Function &F) {
+
+  /*Two passes over the instructions.
+ *  1a)Find the basic blocks associated with each of the file:line pairs.
+ *  1b)For each block found, if it is dominated by another found, remove its corresponding file:line
+ *  2)Iterate over the instructions and add calls to eventFunc
+ */
+  DT->recalculate(F);
+  std::string fname;
+  hash_map< unsigned int, Function::iterator > blks;
+  for (Function::iterator b = F.begin(), be = F.end(); b != be; ++b) {
+    for (BasicBlock::iterator i = b->begin(), ie = b->end(); i != ie; ++i) {
+
+      MDNode *md = i->getMetadata("dbg");
+      DILocation loc(md);
+      std::string filename = loc.getFilename().str();
+      unsigned int line = loc.getLineNumber();
+      if (filename.length() == 0){ // No source line.
+        continue;
+      }
+      fname = filename;
+      blks[line] = Function::iterator(*b); 
+    }
+  }
+
+  unsigned num = 0;
+  hash_map< unsigned int, Function::iterator >::iterator b,e;
+  for(b = blks.begin(), e = blks.end(); b!=e; b++){
+
+    hash_map< unsigned int, Function::iterator >::iterator ib,ie;
+    for(ib = b, ie = blks.end(); ib!=ie; ib++){
+
+      if( b == ib ){ continue; }
+
+      if( dominates(&(*(b->second)),&(*(ib->second))) ){
+        std::pair<std::string, unsigned int> point(fname, ib->first);
+        if(points.find( std::pair<std::string, unsigned int>(fname, b->first)) != points.end()){
+          if(points.erase(point)){
+            std::cerr << "[AVISO] " << fname << " " << b->first << " dominates " << ib->first << "\n";
+            num++;
+          }
+        }
+      }
+
+    }
+    
+  }
+
+  if(num > 0){
+    std::cerr << "[AVISO] Eliminated " << num << " events.\n";
+  }
+  
+  for (Function::iterator b = F.begin(), be = F.end(); b != be; ++b) {
+    for (BasicBlock::iterator i = b->begin(), ie = b->end(); i != ie; ++i) {
+
+      MDNode *md = i->getMetadata("dbg");
+      DILocation loc(md);
+      std::string filename = loc.getFilename().str();
+      unsigned int line = loc.getLineNumber();
+      if (filename.length() == 0){ // No source line.
+        continue;
+      }
+      std::pair<std::string, unsigned int> point(filename, line);
+      if (points.erase(point)) {
+      
+        std::cerr << "[AVISO] Instrumenting " << filename << ":" << line << "\n";
+        std::vector<Value *> params = std::vector<Value *>();
+        CallInst::Create(eventFunc, ArrayRef<Value *>(params), "", &(*i));
+
+      }
+    }
+  }
+
+  return true;
+
+}
+
diff -rupN llvm-3.1.src/lib/Transforms/Instrumentation/Instrumentation.cpp llvm-3.1.src.aviso/lib/Transforms/Instrumentation/Instrumentation.cpp
--- llvm-3.1.src/lib/Transforms/Instrumentation/Instrumentation.cpp	2012-02-13 14:50:51.000000000 -0800
+++ llvm-3.1.src.aviso/lib/Transforms/Instrumentation/Instrumentation.cpp	2012-08-02 14:58:58.000000000 -0700
@@ -26,6 +26,7 @@ void llvm::initializeInstrumentation(Pas
   initializeGCOVProfilerPass(Registry);
   initializeAddressSanitizerPass(Registry);
   initializeThreadSanitizerPass(Registry);
+  initializeAvisoInstrumentPass(Registry);
 }
 
 /// LLVMInitializeInstrumentation - C binding for
